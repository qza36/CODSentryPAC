# CODSentryPAC - 轨迹生成系统

## 项目简介

这是一个基于 ROS2 的机器人轨迹生成系统，采用多层次路径规划架构，实现从起点到终点的平滑、安全的运动轨迹生成。

## 系统架构

```
┌─────────────────────────────────────────────────────────────┐
│                    planner_manager                          │
│                   (规划管理器)                               │
└─────────────────────────────────────────────────────────────┘
                            │
        ┌───────────────────┼───────────────────┐
        │                   │                   │
        ▼                   ▼                   ▼
┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│ TopoSearcher │    │ AstarFinder  │    │  GlobalMap   │
│  (拓扑搜索)   │    │  (A*优化)    │    │  (地图管理)   │
└──────────────┘    └──────────────┘    └──────────────┘
        │                   │
        └───────────────────┘
                │
                ▼
        ┌──────────────┐
        │   Smoother   │
        │  (路径平滑)   │
        └──────────────┘
                │
                ▼
        ┌──────────────┐
        │ Refenecesmooth│
        │ (参考轨迹生成) │
        └──────────────┘
```

### 核心模块

| 模块 | 文件 | 功能 |
|------|------|------|
| 规划管理器 | `plannerManger.hpp/cpp` | 统一管理路径规划流程 |
| 地图管理 | `GridMap.hpp/cpp` | 3D 网格地图、障碍物检测 |
| 拓扑搜索 | `TopoSearch.hpp/cpp` | 基于 PRM 的多路径搜索 |
| A* 搜索 | `Astar_searcher.hpp/cpp` | 路径剪枝和碰撞检测 |
| 路径平滑 | `path_smooth.hpp/cpp` | L-BFGS 样条优化 |
| 参考轨迹 | `reference_path.hpp/cpp` | 三次样条时间参数化 |

## 路径生成流程

系统采用四层递进式的路径生成方法：

```
起点/终点 → 拓扑搜索 → A*优化 → 路径平滑 → 参考轨迹生成 → 输出
```

### 第一层：拓扑路径搜索

**算法**：基于 PRM (Probabilistic Roadmap)

**作用**：在复杂环境中快速找到一条可行路径

**流程**：
1. 在地图中随机采样无碰撞点作为守卫节点
2. 检查节点间的可见性（是否可直线连接）
3. 将可见节点连接成拓扑图
4. 使用 Dijkstra 算法搜索从起点到终点的最短路径

**输出**：一条由多个路径点组成的初始路径，可能包含较多转折点

**代码位置**：`TopoSearch.cpp:createGraph()`, `TopoSearch.cpp:searchPaths()`

### 第二层：A* 路径优化

**作用**：对拓扑路径进行剪枝，减少不必要的转折点

**算法**：贪心剪枝
- 检查路径中的三个连续点
- 如果第一个点和第三个点之间可以直线连接（无碰撞）
- 则删除中间点，简化路径

**效果**：
- 减少路径点数量
- 使路径更加直接
- 降低后续计算量

**代码位置**：`Astar_searcher.cpp:smoothTopoPath()`

### 第三层：路径平滑

这是系统的核心优化模块，使用 L-BFGS 优化算法对路径进行平滑处理。

#### 步骤 1：路径采样

将不均匀的路径点转换为固定间隔的采样点（间隔 0.3 米），便于后续优��。

```
输入：[P0, P1, P2, P3]  (不均匀间隔)
输出：[S0, S1, S2, S3, S4, S5, ...]  (0.3米间隔)
```

**代码位置**：`path_smooth.cpp:pathSample()`

#### 步骤 2：L-BFGS 优化

**优化目标**：生成一条既平滑又避开障碍物的路径

**代价函数**：
```
总代价 = 平滑能量 + 障碍物惩罚
```

**平滑能量**：
- 通过三次样条计算路径的曲率
- 最小化路径的加速度和急转弯
- 使路径更加平滑自然

**障碍物惩罚**：
- 对于每个路径点，检测周围的障碍物
- 如果距离障碍物太近（小于 0.3 米），施加惩罚
- 距离越近，惩罚越大（二次惩罚函数）
- 迫使路径远离障碍物

**障碍物检测方法**：
1. **局部网格搜索**：在当前点周围的网格中搜索障碍物
2. **径向射线搜索**：从当前点向四周发射 100 条射线，精确定位障碍物边缘

**优化算法**：L-BFGS（Limited-memory BFGS）
- 一种高效的拟牛顿优化算法
- 通过迭代调整路径点位置，最小化代价函数
- 自动计算梯度，找到最优解

**代码位置**：`path_smooth.cpp:smoothPath()`, `path_smooth.cpp:costFunction()`, `path_smooth.cpp:getObsEdge()`

#### 步骤 3：路径重采样

将优化后的样条曲线重新采样为离散路径点，输出最终的平滑路径。

**代码位置**：`path_smooth.cpp:pathResample()`

### 第四层：参考轨迹生成

将平滑后的几何路径转换为带时间信息的参考轨迹，供控制器使用。

#### 步骤 1：时间分配

为路径的每一段分配时间，决定机器人在每段的运动速度。

**基础计算**：
```
时间 = 路径长度 / 期望速度
```

**地形自适应**：
- **平地**：按基准速度行驶
- **坡道**：根据坡度自动减速（坡度越大，减速越多）
- **桥洞**：识别低矮区域，自动减速通过

**代码位置**：`reference_path.cpp:solveTrapezoidalTime()`

#### 步骤 2：三次样条插值

使用三次样条插值生成平滑的轨迹曲线。

**样条方程**：
```
x(t) = a + b*t + c*t² + d*t³
```

**特点**：
- 保证位置、速度、加速度连续（C² 连续）
- 起点速度可指定
- 终点速度为 0（停止）

**求解方法**：带状矩阵 LU 分解
- 构建线性方程组
- 利用带状矩阵的稀疏性，高效求解
- 时间复杂度 O(N)

**代码位置**：`reference_path.cpp:solvePolyMatrix()`

#### 步骤 3：可行性检查

检查生成的轨迹是否满足动力学约束。

**检查内容**：加速度是否超过最大值

**处理方法**：
- 如果某段加速度过大，增加该段及相邻段的时间分配
- 重新求解样条插值
- 最多迭代 3 次，直到满足约束

**代码位置**：`reference_path.cpp:checkfeasible()`

#### 步骤 4：轨迹采样

按固定时间步长（50ms）对轨迹进行采样，生成离散的参考点。

**输出**：
- 位置序列：`[(x₀, y₀, z₀), (x₁, y₁, z₁), ...]`
- 速度序列：`[(vₓ₀, vᵧ₀, vᵧ₀), ...]`
- 时间戳序列：`[0, 0.05, 0.10, ...]`

**代码位置**：`reference_path.cpp:getRefTrajectory()`

## 完整流程图

```
┌─────────────┐
│  起点/终点   │
└──────┬──────┘
       │
       ▼
┌─────────────────────────────┐
│  1. 拓扑搜索 (TopoSearcher) │
│  - PRM 采样                 │
│  - 构建拓扑图               │
│  - 搜索可行路径             │
└──────┬──────────────────────┘
       │ 初始路径
       ▼
┌─────────────────────────────┐
│  2. A* 优化 (AstarFinder)   │
│  - 路径剪枝                 │
│  - 减少转折点               │
└──────┬──────────────────────┘
       │ 优化路径
       ▼
┌─────────────────────────────┐
│  3. 路径平滑 (Smoother)     │
│  - 路径采样                 │
│  - L-BFGS 优化              │
│    · 最小化曲率             │
│    · 避开障碍物             │
│  - 路径重采样               │
└──────┬──────────────────────┘
       │ 平滑路径
       ▼
┌─────────────────────────────┐
│  4. 参考轨迹 (Refenecesmooth)│
│  - 时间分配（地形自适应）    │
│  - 三次样条插值             │
│  - 可行性检查               │
│  - 轨迹采样                 │
└──────┬──────────────────────┘
       │
       ▼
┌─────────────────────────────┐
│  输出：参考轨迹 + 速度 + 时间 │
└─────────────────────────────┘
```

## 重规划机制

系统支持动态重规划，应对环境变化。

### 触发条件

1. **路径碰撞**：检测到当前路径与新出现的障碍物碰撞
2. **目标变更**：目标位置发生改变

### 重规划策略

**局部重规划**：
- 仅重新规划发生碰撞的路径段
- 保留未碰撞的部分
- 计算速度快，适合小范围障碍物

**全局重规划**：
- 完整重新规划整条路径
- 保证全局最优
- 适合大范围环境变化或目标变更

**流程**：
```
检测到碰撞
    │
    ├─ 尝试局部重规划
    │   ├─ 成功 → 拼接路径 → 平滑 → 生成轨迹
    │   └─ 失败 → 全局重规划
    │
    └─ 目标变更 → 全局重规划
```

**代码位置**：`plannerManager.cpp:replanFinding()`

## 代码结构

```
trajectory_generation/
├── config/
│   └── planner_config.yaml          # 配置文件
├── include/trajectory_generation/
│   ├── plannerManger.hpp            # 规划管理器
│   ├── GridMap.hpp                  # 地图管理
│   ├── TopoSearch.hpp               # 拓扑搜索
│   ├── Astar_searcher.hpp           # A* 搜索
│   ├── path_smooth.hpp              # 路径平滑
│   ├── reference_path.hpp           # 参考轨迹
│   ├── GridNode.hpp                 # 网格节点
│   ├── planner_config.hpp           # 配置结构
│   └── root_solver/
│       ├── cubic_spline.hpp         # 三次样条
│       ├── lbfgs.hpp                # L-BFGS 优化
│       └── banded_system.hpp        # 带状矩阵求解
├── src/
│   ├── plannerManager.cpp
│   ├── GridMap.cpp
│   ├── TopoSearch.cpp
│   ├── Astar_searcher.cpp
│   ├── path_smooth.cpp
│   └── reference_path.cpp
└── CMakeLists.txt
```

## 编译和运行

### 依赖项

- ROS2 (Humble/Foxy)
- Eigen3
- PCL (Point Cloud Library)

### 编译

```bash
cd /path/to/CODSentryPAC
colcon build --packages-select trajectory_generation
source install/setup.bash
```

### 运行
目前还在开发中

## 路径跟踪控制（后续开发）

### OCS2 控制框架

在轨迹生成之后，系统将使用 **OCS2 (Optimal Control for Switched Systems)** 框架进行路径跟踪控制。

### 控制流程

```
参考轨迹 → OCS2 控制器 → 控制指令 → 机器人执行
    ↑           │
    │           ↓
    └──── 状态反馈 ────┘
```

### OCS2 的作用

**模型预测控制（MPC）**：
- 根据机器人的动力学模型，预测未来一段时间的运动
- 计算最优控制指令，使机器人尽可能跟随参考轨迹
- 实时调整控制策略，应对模型误差和外部干扰

**轨迹跟踪**：
- 输入：参考轨迹（位置、速度、时间）
- 输出：控制指令（速度、加速度或力矩）
- 目标：最小化跟踪误差

**约束处理**：
- 速度约束：限制机器人的最大速度
- 加速度约束：限制机器人的最大加速度
- 输入约束：限制电机的最大输出
- 碰撞约束：保持与障碍物的安全距离

### 工作原理

**1. 状态空间模型**

建立机器人的动力学模型：
```
x(t+1) = f(x(t), u(t))
```
其中：
- `x(t)` 是机器人的状态（位置、速度等）
- `u(t)` 是控制输入（加速度、力矩等）
- `f()` 是动力学方程

**2. 优化问题**

在每个控制周期，求解以下优化问题：
```
最小化：跟踪误差 + 控制代价
约束：动力学方程、速度限制、加速度限制
```

**3. 滚动优化**

- 在当前时刻，预测未来 N 步的运动
- 计算最优控制序列
- 执行第一步控制指令
- 在下一时刻，重新预测和优化（滚动窗口）

### 与轨迹生成的配合

```
┌─────────────────────────────────────────────────────────┐
│                    完整系统流程                          │
└─────────────────────────────────────────────────────────┘

起点/终点
    │
    ▼
┌─────────────────────┐
│  轨迹生成模块        │
│  (trajectory_gen)   │
│  - 拓扑搜索         │
│  - 路径平滑         │
│  - 参考轨迹生成     │
└──────┬──────────────┘
       │ 参考轨迹
       ▼
┌─────────────────────┐
│  OCS2 控制器        │
│  - 模型预测控制     │
│  - 轨迹跟踪         │
│  - 约束处理         │
└──────┬──────────────┘
       │ 控制指令
       ▼
┌─────────────────────┐
│  机器人执行         │
│  - 电机控制         │
│  - 状态反馈         │
└─────────────────────┘
```

### OCS2 的优势

1. **实时性**：高效的优化算法，适合实时控制
2. **鲁棒性**：通过反馈控制，应对模型误差和干扰
3. **约束满足**：严格满足动力学和安全约束
4. **最优性**：在满足约束的前提下，最小化跟踪误差

### 开发计划

- [ ] 建立机器人动力学模型
- [ ] 配置 OCS2 控制器参数
- [ ] 实现轨迹跟踪接口
- [ ] 集成到 ROS2 系统
- [ ] 仿真测试和参数调优
- [ ] 实车测试
